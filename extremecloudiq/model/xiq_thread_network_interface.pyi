# coding: utf-8

"""
    ExtremeCloud IQ API

    ExtremeCloud IQ RESTful API for external and internal applications.  # noqa: E501

    The version of the OpenAPI document: 25.2.0.123
    Contact: support@extremenetworks.com
    Generated by: https://openapi-generator.tech
"""

from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from extremecloudiq import schemas  # noqa: F401


class XiqThreadNetworkInterface(
    schemas.DictSchema
):
    """NOTE: This class is auto generated by OpenAPI Generator.
    Ref: https://openapi-generator.tech

    Do not edit the class manually.

    The thread veth0 network interface
    """


    class MetaOapg:
        
        class properties:
            interface_name = schemas.StrSchema
            is_active = schemas.BoolSchema
            is_broadcast = schemas.BoolSchema
            is_loopback = schemas.BoolSchema
            is_point_to_point = schemas.BoolSchema
            is_running = schemas.BoolSchema
            is_arp = schemas.BoolSchema
            is_promisc = schemas.BoolSchema
            is_all_multi = schemas.BoolSchema
            is_multicast = schemas.BoolSchema
            is_dynamic = schemas.BoolSchema
            mtu = schemas.Int32Schema
            hw_mac_address = schemas.StrSchema
            ipv4 = schemas.StrSchema
            ipv4_mask = schemas.StrSchema
            ipv4_broadcast = schemas.StrSchema
            
            
            class ipv6_settings(
                schemas.ListSchema
            ):
            
            
                class MetaOapg:
                    
                    @staticmethod
                    def items() -> typing.Type['XiqThreadIpv6Setting']:
                        return XiqThreadIpv6Setting
            
                def __new__(
                    cls,
                    _arg: typing.Union[typing.Tuple['XiqThreadIpv6Setting'], typing.List['XiqThreadIpv6Setting']],
                    _configuration: typing.Optional[schemas.Configuration] = None,
                ) -> 'ipv6_settings':
                    return super().__new__(
                        cls,
                        _arg,
                        _configuration=_configuration,
                    )
            
                def __getitem__(self, i: int) -> 'XiqThreadIpv6Setting':
                    return super().__getitem__(i)
            __annotations__ = {
                "interface_name": interface_name,
                "is_active": is_active,
                "is_broadcast": is_broadcast,
                "is_loopback": is_loopback,
                "is_point_to_point": is_point_to_point,
                "is_running": is_running,
                "is_arp": is_arp,
                "is_promisc": is_promisc,
                "is_all_multi": is_all_multi,
                "is_multicast": is_multicast,
                "is_dynamic": is_dynamic,
                "mtu": mtu,
                "hw_mac_address": hw_mac_address,
                "ipv4": ipv4,
                "ipv4_mask": ipv4_mask,
                "ipv4_broadcast": ipv4_broadcast,
                "ipv6_settings": ipv6_settings,
            }
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["interface_name"]) -> MetaOapg.properties.interface_name: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["is_active"]) -> MetaOapg.properties.is_active: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["is_broadcast"]) -> MetaOapg.properties.is_broadcast: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["is_loopback"]) -> MetaOapg.properties.is_loopback: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["is_point_to_point"]) -> MetaOapg.properties.is_point_to_point: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["is_running"]) -> MetaOapg.properties.is_running: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["is_arp"]) -> MetaOapg.properties.is_arp: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["is_promisc"]) -> MetaOapg.properties.is_promisc: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["is_all_multi"]) -> MetaOapg.properties.is_all_multi: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["is_multicast"]) -> MetaOapg.properties.is_multicast: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["is_dynamic"]) -> MetaOapg.properties.is_dynamic: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["mtu"]) -> MetaOapg.properties.mtu: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["hw_mac_address"]) -> MetaOapg.properties.hw_mac_address: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ipv4"]) -> MetaOapg.properties.ipv4: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ipv4_mask"]) -> MetaOapg.properties.ipv4_mask: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ipv4_broadcast"]) -> MetaOapg.properties.ipv4_broadcast: ...
    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["ipv6_settings"]) -> MetaOapg.properties.ipv6_settings: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["interface_name", "is_active", "is_broadcast", "is_loopback", "is_point_to_point", "is_running", "is_arp", "is_promisc", "is_all_multi", "is_multicast", "is_dynamic", "mtu", "hw_mac_address", "ipv4", "ipv4_mask", "ipv4_broadcast", "ipv6_settings", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["interface_name"]) -> typing.Union[MetaOapg.properties.interface_name, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["is_active"]) -> typing.Union[MetaOapg.properties.is_active, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["is_broadcast"]) -> typing.Union[MetaOapg.properties.is_broadcast, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["is_loopback"]) -> typing.Union[MetaOapg.properties.is_loopback, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["is_point_to_point"]) -> typing.Union[MetaOapg.properties.is_point_to_point, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["is_running"]) -> typing.Union[MetaOapg.properties.is_running, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["is_arp"]) -> typing.Union[MetaOapg.properties.is_arp, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["is_promisc"]) -> typing.Union[MetaOapg.properties.is_promisc, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["is_all_multi"]) -> typing.Union[MetaOapg.properties.is_all_multi, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["is_multicast"]) -> typing.Union[MetaOapg.properties.is_multicast, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["is_dynamic"]) -> typing.Union[MetaOapg.properties.is_dynamic, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["mtu"]) -> typing.Union[MetaOapg.properties.mtu, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["hw_mac_address"]) -> typing.Union[MetaOapg.properties.hw_mac_address, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ipv4"]) -> typing.Union[MetaOapg.properties.ipv4, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ipv4_mask"]) -> typing.Union[MetaOapg.properties.ipv4_mask, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ipv4_broadcast"]) -> typing.Union[MetaOapg.properties.ipv4_broadcast, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["ipv6_settings"]) -> typing.Union[MetaOapg.properties.ipv6_settings, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["interface_name", "is_active", "is_broadcast", "is_loopback", "is_point_to_point", "is_running", "is_arp", "is_promisc", "is_all_multi", "is_multicast", "is_dynamic", "mtu", "hw_mac_address", "ipv4", "ipv4_mask", "ipv4_broadcast", "ipv6_settings", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, ],
        interface_name: typing.Union[MetaOapg.properties.interface_name, str, schemas.Unset] = schemas.unset,
        is_active: typing.Union[MetaOapg.properties.is_active, bool, schemas.Unset] = schemas.unset,
        is_broadcast: typing.Union[MetaOapg.properties.is_broadcast, bool, schemas.Unset] = schemas.unset,
        is_loopback: typing.Union[MetaOapg.properties.is_loopback, bool, schemas.Unset] = schemas.unset,
        is_point_to_point: typing.Union[MetaOapg.properties.is_point_to_point, bool, schemas.Unset] = schemas.unset,
        is_running: typing.Union[MetaOapg.properties.is_running, bool, schemas.Unset] = schemas.unset,
        is_arp: typing.Union[MetaOapg.properties.is_arp, bool, schemas.Unset] = schemas.unset,
        is_promisc: typing.Union[MetaOapg.properties.is_promisc, bool, schemas.Unset] = schemas.unset,
        is_all_multi: typing.Union[MetaOapg.properties.is_all_multi, bool, schemas.Unset] = schemas.unset,
        is_multicast: typing.Union[MetaOapg.properties.is_multicast, bool, schemas.Unset] = schemas.unset,
        is_dynamic: typing.Union[MetaOapg.properties.is_dynamic, bool, schemas.Unset] = schemas.unset,
        mtu: typing.Union[MetaOapg.properties.mtu, decimal.Decimal, int, schemas.Unset] = schemas.unset,
        hw_mac_address: typing.Union[MetaOapg.properties.hw_mac_address, str, schemas.Unset] = schemas.unset,
        ipv4: typing.Union[MetaOapg.properties.ipv4, str, schemas.Unset] = schemas.unset,
        ipv4_mask: typing.Union[MetaOapg.properties.ipv4_mask, str, schemas.Unset] = schemas.unset,
        ipv4_broadcast: typing.Union[MetaOapg.properties.ipv4_broadcast, str, schemas.Unset] = schemas.unset,
        ipv6_settings: typing.Union[MetaOapg.properties.ipv6_settings, list, tuple, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'XiqThreadNetworkInterface':
        return super().__new__(
            cls,
            *_args,
            interface_name=interface_name,
            is_active=is_active,
            is_broadcast=is_broadcast,
            is_loopback=is_loopback,
            is_point_to_point=is_point_to_point,
            is_running=is_running,
            is_arp=is_arp,
            is_promisc=is_promisc,
            is_all_multi=is_all_multi,
            is_multicast=is_multicast,
            is_dynamic=is_dynamic,
            mtu=mtu,
            hw_mac_address=hw_mac_address,
            ipv4=ipv4,
            ipv4_mask=ipv4_mask,
            ipv4_broadcast=ipv4_broadcast,
            ipv6_settings=ipv6_settings,
            _configuration=_configuration,
            **kwargs,
        )

from extremecloudiq.model.xiq_thread_ipv6_setting import XiqThreadIpv6Setting
